---
title: "Analysis_LoL"
author: "Marshall Gallt"
date: "2/28/2022"
output: github_document
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(knitr)
library(lubridate)
library(corrplot)
library(Hmisc)

```


# Introduction

League of Legends is a popular PC game. Teams all around the world compete with
the hopes of making it to Worlds. Riot has released data for each player of each
professional game of the 2022 season thus far. In this project I will perform 
logistic regression in R on the `2022 Match Data` found on Oracle Elixir's 
[downloads page](https://oracleselixir.com/tools/downloads).
`2022_LoL_esports_match_data_from_OraclesElixir_20220228.csv`


# Research Questions

In this logistic regression a number of questions could be posed. Examples
include, what indicates a winning score for each role, when is gold income the
most important, what objectives are the most decisive, how do the teams and
leagues differentiate in strategy.

# Data

First, a quick view of our data.


```{r data, warning=FALSE}

Lol_match_data_2022 <- 
  read_csv("2022_LoL_esports_match_data_from_OraclesElixir_20220228.csv")

head(Lol_match_data_2022)

```

The data we have available is quite large and detailed. So I will be reducing 
the data to; key variables, the "LCS"(North American) `league`, and the entire 
teams stats as valued as "team" for the `position` variable.

```{r reduce, warning=FALSE}

LCS_matches <- Lol_match_data_2022 %>%
  filter(league == "LCS",
         position == "team") %>%
  subset(select = c('gameid',
                    'side',
                    'gamelength',
                    'result',
                    'firstblood',
                    'team kpm',
                    'firstdragon',
                    'dragons',
                    'firstbaron',
                    'barons',
                    'firsttower',
                    'towers',
                    'firstmidtower',
                    'firsttothreetowers',
                    'inhibitors',
                    'vspm',
                    'earned gpm',
                    'cspm'))
head(LCS_matches)

```

Variable | Type | Description
---------|------|------------
gameid | Character | Game identification (two teams)
side | Categorical | Side of the map given to team (Red or Blue)
gamelength | Numeric | Length of game in seconds
result | Binary | Win = 1, lose = 0
team kpm | Numeric | Team's kills per minute
firstdragon | Binary | True if team killed first dragon
dragons | Numeric | Number of dragons killed by team
firstbaron | Binary | True if team killed first baron
barons | Numeric | Numer of dragons killed by team
firsttower | Binary | True if team destroyed first tower
towers | Numeric | Number of towers destroyed by team
firstmidtower | Binary | True if team destroyed the first mid tower
firsttothreetowers | Binary | True if team was first to destroy three towers
inhibitors | Numeric | Number of inhibitors destroyed by team
vspm | Numeric | Team's vision score per minute
earned gpm | Numeric | Team's gold earned per minute
cspm | Numeric | Team's creep score per minute


# Exploratory Data Analysis

First, we conduct an exploratory data analysis.



## Numerical Summaries

```{r summary}
summary(LCS_matches)

```


## Graphical Summaries

### 

```{r summary-tables-1, warning=FALSE}

LCS_matches %>%
  data.matrix() %>%
  cor()%>%
  corrplot(is.corr = FALSE, order = 'FPC')

```
### Checking data for relationships
To check the shape of the data columns to see if they might be well fit by
any particular random variables, and if there are any outliers, 
we plot histograms of each variable. These reveal that to our luck, there
aren't any serious outliers and that also specific pieces of data seem to fit
specific distributions such as
Normal - gamelength, vspm, cspm
Pareto/Exponential - inhibitors
Bivariate Normal - towers

This provides us some insight onto the nature of how these might affect game 
outcomes.

```{r }
hist.data.frame(LCS_matches)
```

```{r whiskerplot}

num_LCS <- LCS_matches %>%
  select_if(is.numeric)

for(i in 1:11) {
   boxplot(num_LCS[,i], main=names(num_LCS)[i])
}

```
```{r boxplot}

non_num_LCS <- LCS_matches %>%
  select_if(negate(is.numeric))
non_num_LCS

#for (i in 1:7) {
#  non_num_LCS %>%
#    count(i)
#}


```

# Data Cleaning



# Data Analysis



# Hypotheses



# Modeling



# Conclusion




